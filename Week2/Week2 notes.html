<!-- Comments in JavaScript are done with // for single line and /* for long comments
semicolons are optional but using them is best practice
data types are string, symbol, number, boolean, undefined, and null.

typeof __ will return what type

Declare variables with const or let.  var is considered outdated.  
const = constant...can't be reassigned.  let can be reassigned.  Both have
limited scope to the block they are in.  var was global.  use camel-case. 
ex: let x = 3, y = 4, z = 5;

Strings: Either "" or '' work. Can't use ' inside string unless you used " " to wrap. 
Or you can escape character it like " It\'s me"

To access a property of a variable can use .  ex:  name.length

To call a method use variable.method()  ex: name.toUpperCase(); or name.toLowerCase(); 

Common methods not mentioned already:  indexOf("x"), charAT("x"), lastIndexOf("x"),
includes("x"), startsWith("x"), endsWith("x"), variable.concat("string") or "string" + "string",
.trim() removes whitespace before and after, 

template literals are `` and used like "" around a string.  They allow quotes marks within string,
and you can put code in string like `String ${javascript} more string`  Line breaks are converted into
\n automatically.  

symbols are new...used to make unique values like ids. Need a description with them. 
Description gets logged to console when symbol is used.  String(uniqueID) will return description. 
ex: const uniqueID= Symbol("This is a unique ID")

Numbers refer to ints or floats interchangably. If it starts with 0x it's in hexadecimal notation (base 16).  0o is for base 8. 
0b is base 2.  Exponential notation or scientific notion is done with an e...aka 2e3 means 2 X 10^3

to use a method with an interger add a space before use two .. or write as a decimal.  Can also declare as const  
ex:  5 .toExpontential(); 5..toExpontential(); or 5.0.toExpontential(); 

common number methods:  .toFixed(x) rounds to that many decimal places.  returns a string not a number;

toPrecision(x) is simlar...but often exponential notation

numbers use +_*/% and ** is ^.  Can also use +=, ++, -- etc.  points++ returns points then adds,
++points adds then displays.  

+-infinity is an error for too big to display.  NaN means not a number. 

can check if number can be used with number.isFinite();. 

javascript will try to convert strings to numbers when used, but it's not consistent. 

number("string") converts to number.  String(x) converts number to string. also can use .toString() parseInt(number,base) converts out of different bases. This also will pull numbers
out of a string that starts with numbers like an address.  parseFloat() is similar. 

Empty strings and 0 will evulate to fake false, everything else tends to be fake true
!= Not
&& = and
||= or
== is equals. doesn't tell between string numbers and numbers. 
also has bitwise operators.  
=== also equals but needs matching data type. doesn't work with NaN needs to be isNaN(x).
also has >,<,<=.>=  Quiz Ninja Example below
-->
<!DOCTYPE html>
<html>
  <body>
    <h1>Quiz Ninja</h1>
    <script>
      const quiz = new Map([
        ["What is Superman's real name?", "Clark Kent"],
        ["What is Wonder Woman's real name?", "Diana Prince"],
        ["What is Batman's real name?", "Bruce Wayne"],
      ]);

      function start(quiz) {
        let score = 0;
        for (const [question, answer] of quiz.entries()) {
          const response = ask(question);
          check(response, answer);
        }

        gameOver();
        function ask(question) {
          return prompt(question);
        }
        function check(response, answer) {
          if (response === answer) {
            alert("Correct!");
            score++;
          } else {
            alert("Wrong.");
          }
        }
        function gameOver() {
          alert("Game Over, you scored " + score);
        }
        //const question = "What is Superman's real name?";
        //const answer = prompt(question);
        //alert("You answered " + answer);
      }
      start(quiz);
    </script>
    <h1>Looping a Triangle</h1>
    <p id="body"></p>
    <script>
      let string = "#";
      for (let x = 0; x < 7; x++) {
        let newElement = document.createElement("p");
        newElement.textContent = string;
        document.getElementById("body").appendChild(newElement);
        string += "#";
      }
    </script>
    <h1>FizzBuzz</h1>
    <p id="numberList"></p>
    <script>
      for (let i = 1; i <= 100; i++) {
        if (i % 3 == 0) {
          let newElement = document.createElement("p");
          newElement.textContent = "Fizz";
          document.getElementById("numberList").appendChild(newElement);
        } else if (i % 5 == 0) {
          let newElement = document.createElement("p");
          newElement.textContent = "Buzz";
          document.getElementById("numberList").appendChild(newElement);
        } else {
          let newElement = document.createElement("p");
          newElement.textContent = i;
          document.getElementById("numberList").appendChild(newElement);
        }
      }
    </script>

    <h1>Minimum</h1>
    see console
    <script>
      function min(x, y) {
        if (x < y) {
          return x;
        } else {
          return y;
        }
      }
      console.log(min(0, 10));
      // → 0
      console.log(min(0, -10));
      // → -10
    </script>
    <h1>Sum of a Range</h1>
    see console
    <script>
      function range(x, y, z = 1) {
        let array = [];
        if (x <= y) {
          for (i = x; i <= y; i += z) {
            array.push(i);
          }
        } else {
          for (i = x; i >= y; i += z) {
            array.push(i);
          }
        }
        return array;
      }
      function sum(array) {
        let sum = 0;
        for (i = 0; i<array.length; i++) {
          sum += array[i];
        }
        return sum;
      }

      console.log(range(1, 10));
      // → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      console.log(range(5, 2, -1));
      // → [5, 4, 3, 2]
      console.log(sum(range(1, 10)));
      // → 55
    </script>
  </body>
</html>

<!-- Array, Logic, and Loops notes
ex: const myArray=[]; 
to fill:  heros[0]= "Superman" or const avengers= ["captain America", "Iron Man", "thor", "hulk"];
Can be mixed types.  
delete avengers[3]; //deletes and replaces with undefined

destructuring array= takes values out of array and assigns them.  aka:
const [x,y]=[1,2]; 
Properties:  
.length
methods:
.pop() // takes off and returns last item. 
.shift() //takes off and returns first item. 
.push() // adds to end
.unshift()//adds to beggining. 
.concat() merges array with a different one. 
.join.() turns into string with commas. can put string in with different separator. 
.slice(x,y)takes a subarray starting with first and ending with last.  Doesn't change originally array.
.splice(x,y, string) removes y(can be 0) many items starting at x and replaces with string(can be ommited)
.reverse() reverses it
.sort() alphabetizes it.  needs a function passed as an argument to work right with numbers
.indexOf(string) returns index of string.  if not there returns -1
.includes(string)

multidemensional arrays
declared like:
const coordinates=[[1,3],[4,2]]
to refer to a spot needs two indexes first refers to outer array place, second inner place
so coordinates[0][0] would refer to 1
and coordinates [1][1] would be 2
can be flattened using spread:  ex:
const summer = ['Jun', 'Jul', 'Aug'];
const winter = ['Dec', 'Jan', 'Feb'];
const nested = [ summer, winter ];
<< [ [ 'Jun', 'Jul', 'Aug' ], [ 'Dec', 'Jan', 'Feb' ] ]
const flat = [...summer, ...winter];
<< [ 'Jun', 'Jul', 'Aug', 'Dec', 'Jan', 'Feb' ]

sets are like arrays or list with no duplicate values allowed. strings get added as letters with deleted duplicate letters. 
Can have arrays or objects with same values as others. type sensitive aka 2 and "2" can both be added.  
no idexes. 
declared ex:
const list= new Set(); or
const numbers=new Set([1,2,3])

methods: 
.add(x)
.size()
.has() returns boolean
.delete(x) removes value...returns true if done, false if not. 
.clear() removes all.

can covert to array by using spread variable.  
ex: 
const shoppingArray = [...shoppingSet]
shoppingArray
<< [ 'Apples', 'Bananas', 'Beans' ]

Maps- stores value with an index tied to it.  I'm a bit fuzzy on these.
ex: const heroes = new Map([ ['Clark Kent','Superman'],
['Bruce Wayne', 'Batman']
]);
or 
const romanNumerals = new Map();
romanNumerals.set(1,'I');
<< Map { 1 => 'I' }

Logic
If:  
if (condition){

}
if else:
if(condition){

}else { 

}
ternary operator-a shorthand for if/else.  ex:
condition ? (runs if true):(runs if false)
switch statements--like giant if else else else block.
switch (number){
    case 3:
        console.log("its three")
        break; 
    case 2:
        break; 
     default:    
}
Loops: 
While- 
while(condition){

}
do..while
do{

}while(condition)

for:

for (let x=0; x<10, x++){

}

loop through a set:  
const letters = new Set('hello');
for(const letter of letters) {
    console.log(letter);
}
<< h
e
l
o

Ch 4 
function literal=
function hello(){
    console.log("hello world")
}

anonymous function expression=  question--what gets stored? if nothing is specified it returns undefined.  if return statement...then return.
const goodbye= function(){
    console.log("Goodby World!")
};
named function expression=
const goodbye= function bye(){
    console.log("Goodby World!")
};

constructor function--don't use this.: 
const hi = new Function('console.log("Hi World!");');

to use: just use name followed by parenthesis...ex:
hello();
return values-  all functions return at least undefined...need to specify return line
ex:
function howdy(){
    return "Howdy World";
}
when writing a function inside the () is a parameter...when using it it becomes an argument. 
if it needs an argument and doesn't get it..returns NaN.  If it's to many...it ignores extra.

can refer to things passsed in using variable called arguments.  These can have index notation and length.  
No slice, join, or ForEach.  Better to use rest operator instead.  to use place ...before argument.
It's actually an array. ex:
function rest(...args){
    return args. 
}
default parameter--assign a value when your defining the function
Needs to be last parameter or it will tend to break. ex:
function hello(name="world"){}

arrow functions:  Needs parenthesis for more than one parameter.  
Always will be anonymous unless attached to a variable. examples: 
const square = x => x*x;
const add = (x,y) => x + y;
const hello = () => alert('Hello World!');

Callback- passing in a function as an argument. Don't use parenthesis.  

used in sorting numbers.  
function numerically(a,b){
    return a-b;
}
> [1,3,12,5,23,18,7].sort(numerically);
<< [1, 3, 5, 7, 12, 18, 23]

For big and negative numbers that overflow--use 
function numerically (a,b) {
    if (a < b) {
        return -1;
    } else if (a> b) {
        return 1;
    } else {
        return 0;
    }
}
forEach()- takes 3 parameters (value in the array, current index, array that callback is on)
colors.forEach( (color,index) =>
    console.log(`Color at position ${index}  is ${color}`) );
<<  "Color at position 0 is Red"
    "Color at position 1 is Green"
    "Color at position 2 is Blue"

    map()- used while processing arrays.  
    Ex:
    [1,2,3].map( square )
    << [1, 4, 9]
or 
    [1,2,3].map( x => 2 * x);
    << [2,4,6]

    reduce(total,next value)- also iterates...but combines to single value.  
    filter()- returns a new array with only items that evaluate as true in callback.
    ex: const numbers = [ 2, 7, 6, 5, 11, 23, 12 ]
numbers.filter(x => x%2 === 0 ); // this returns true if the number is even
<< [ 2, 6, 12 ]
-->
